import{_ as i,c as a,o as e,ae as t}from"./chunks/framework.C1dBqGw7.js";const c=JSON.parse('{"title":"パフォーマンスチューニングガイド","description":"","frontmatter":{},"headers":[],"relativePath":"performance_tuning.md","filePath":"performance_tuning.md"}'),n={name:"performance_tuning.md"};function h(l,s,p,r,o,d){return e(),a("div",null,[...s[0]||(s[0]=[t('<h1 id="パフォーマンスチューニングガイド" tabindex="-1">パフォーマンスチューニングガイド <a class="header-anchor" href="#パフォーマンスチューニングガイド" aria-label="Permalink to &quot;パフォーマンスチューニングガイド&quot;">​</a></h1><p>NanaSQLiteは、標準構成でも高速に動作するように設計されていますが、適切な開発パターンと設定を選択することで、その性能を数倍〜数十倍に引き出すことが可能です。</p><hr><h2 id="🚀-核心となる最適化-バッチ操作の活用" tabindex="-1">🚀 核心となる最適化: バッチ操作の活用 <a class="header-anchor" href="#🚀-核心となる最適化-バッチ操作の活用" aria-label="Permalink to &quot;🚀 核心となる最適化: バッチ操作の活用&quot;">​</a></h2><p>SQLiteにおいて最も実行コストが高いのは「トランザクションの開始とコミット」です。</p><h3 id="❌-アンチパターン-ループ内での個別書き込み" tabindex="-1">❌ アンチパターン: ループ内での個別書き込み <a class="header-anchor" href="#❌-アンチパターン-ループ内での個別書き込み" aria-label="Permalink to &quot;❌ アンチパターン: ループ内での個別書き込み&quot;">​</a></h3><p>以下のコードは、1回のループごとにディスクI/Oが発生するため非常に低速です。</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 1000回のディスクコミットが発生（数秒〜数十秒かかる場合がある）</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> range</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">):</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    db[</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">f</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;key_</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">{</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">}</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i</span></span></code></pre></div><h3 id="✅-推奨パターン-batch-update-batch-get" tabindex="-1">✅ 推奨パターン: <code>batch_update</code> / <code>batch_get</code> <a class="header-anchor" href="#✅-推奨パターン-batch-update-batch-get" aria-label="Permalink to &quot;✅ 推奨パターン: `batch_update` / `batch_get`&quot;">​</a></h3><p>NanaSQLiteのバッチ操作用メソッドを使用すると、1回のトランザクションでまとめて処理されるため、劇的に高速化します。</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 1回のディスクコミットで完了（ミリ秒単位で終了）</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">f</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;key_</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">{</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">}</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> range</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)}</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">db.batch_update(data)</span></span></code></pre></div><p><strong>ベンチマーク指標</strong>: 大量書き込みにおいて、個別更新に比べ <strong>10倍〜100倍以上</strong> の高速化が期待できます。</p><hr><h2 id="⚡-データベース設定の最適化" tabindex="-1">⚡ データベース設定の最適化 <a class="header-anchor" href="#⚡-データベース設定の最適化" aria-label="Permalink to &quot;⚡ データベース設定の最適化&quot;">​</a></h2><h3 id="wal-write-ahead-logging-モード" tabindex="-1">WAL (Write-Ahead Logging) モード <a class="header-anchor" href="#wal-write-ahead-logging-モード" aria-label="Permalink to &quot;WAL (Write-Ahead Logging) モード&quot;">​</a></h3><p>NanaSQLiteはデフォルトで <code>optimize=True</code> 設定時に <strong>WALモード</strong> を有効にします。</p><ul><li><strong>メリット</strong>: 書き込み中も読み込みがブロックされず、並行性が向上します。</li><li><strong>注意</strong>: ネットワークドライブ（NFS/SMB）上ではWALモードが動作しない、または不安定になる場合があります。</li></ul><h3 id="メモリマップドi-o-mmap" tabindex="-1">メモリマップドI/O (mmap) <a class="header-anchor" href="#メモリマップドi-o-mmap" aria-label="Permalink to &quot;メモリマップドI/O (mmap)&quot;">​</a></h3><p>読み込みパフォーマンスを向上させるために、SQLiteの <code>mmap_size</code> を活用しています。デフォルトでは256MBが割り当てられています。</p><hr><h2 id="🧠-キャッシュ戦略-v1-3-0" tabindex="-1">🧠 キャッシュ戦略 (v1.3.0+) <a class="header-anchor" href="#🧠-キャッシュ戦略-v1-3-0" aria-label="Permalink to &quot;🧠 キャッシュ戦略 (v1.3.0+)&quot;">​</a></h2><p>NanaSQLiteは、メモリ使用量と速度のバランスを最適化するために、複数のキャッシュ戦略を提供しています。</p><h3 id="_1-無制限キャッシュ-cachetype-unbounded" tabindex="-1">1. 無制限キャッシュ (<code>CacheType.UNBOUNDED</code>) <a class="header-anchor" href="#_1-無制限キャッシュ-cachetype-unbounded" aria-label="Permalink to &quot;1. 無制限キャッシュ (`CacheType.UNBOUNDED`)&quot;">​</a></h3><p><strong>デフォルトの動作</strong>です。一度アクセスしたデータは、メモリが許す限りすべてキャッシュされます。</p><ul><li><strong>メリット</strong>: 同一キーへの再アクセスが最速。</li><li><strong>注意</strong>: データ量が非常に多い場合、メモリ不足（OOM）の原因になる可能性があります。</li></ul><h3 id="_2-lruキャッシュ-cachetype-lru" tabindex="-1">2. LRUキャッシュ (<code>CacheType.LRU</code>) <a class="header-anchor" href="#_2-lruキャッシュ-cachetype-lru" aria-label="Permalink to &quot;2. LRUキャッシュ (`CacheType.LRU`)&quot;">​</a></h3><p><strong>v1.3.0で導入</strong>されました。キャッシュサイズ（項目数）に上限を設け、古いデータから自動的に破棄します。</p><ul><li><strong>使用方法</strong>: <code>cache_strategy=CacheType.LRU, cache_size=1000</code> のように指定します。</li><li><strong>メリット</strong>: メモリ使用量を一定に保つことができます。</li></ul><h3 id="⚡-高速化オプション-orjson-lru-dict" tabindex="-1">⚡ 高速化オプション: <code>orjson</code> + <code>lru-dict</code> <a class="header-anchor" href="#⚡-高速化オプション-orjson-lru-dict" aria-label="Permalink to &quot;⚡ 高速化オプション: `orjson` + `lru-dict`&quot;">​</a></h3><p>JSON のシリアライズ・デシリアライズを高速化するために <strong>orjson</strong> を活用します。</p><ul><li><strong>orjson</strong>: 標準 <code>json</code> モジュールと比較して <strong>3~5倍高速</strong> です。</li><li><strong>lru-dict</strong>: C拡張で実装された超高速な LRU データ構造。</li></ul><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># クォート推奨（Zsh等のシェル対策）</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pip</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;nanasqlite[speed]&quot;</span></span></code></pre></div><p>インストールされている場合、NanaSQLite は自動的にこれらを検知して使用します。未インストールの場合は標準ライブラリ（<code>json</code>, <code>OrderedDict</code>）へフォールバックします。</p><h3 id="_3-ttlキャッシュ-cachetype-ttl" tabindex="-1">3. TTLキャッシュ (<code>CacheType.TTL</code>) <a class="header-anchor" href="#_3-ttlキャッシュ-cachetype-ttl" aria-label="Permalink to &quot;3. TTLキャッシュ (`CacheType.TTL`)&quot;">​</a></h3><p><strong>v1.3.1で導入</strong>されました。データの有効期限を設定し、古いデータを自動的に無効化します。</p><ul><li><strong>使用方法</strong>: <code>cache_strategy=CacheType.TTL, cache_ttl=3600</code> (1時間)</li><li><strong>Persistence TTL</strong>: <code>cache_persistence_ttl=True</code> を設定すると、キャッシュ失効時に SQLite からも自動的に削除されます。セッション管理などに最適です。</li></ul><h3 id="📌-テーブルごとの個別設定" tabindex="-1">📌 テーブルごとの個別設定 <a class="header-anchor" href="#📌-テーブルごとの個別設定" aria-label="Permalink to &quot;📌 テーブルごとの個別設定&quot;">​</a></h3><p>特定のテーブル（巨大なログテーブルなど）だけメモリ使用を抑えたい場合に有効です。</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># メインDBは無制限、logsテーブルだけ最新100件をキャッシュ</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">logs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> db.table(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;logs&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">cache_strategy</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CacheType.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">LRU</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">cache_size</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># セッションテーブルには 30分(1800s) の TTL を設定し、DBからも自動削除</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sessions </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> db.table(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;sessions&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    cache_strategy</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CacheType.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TTL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    cache_ttl</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1800</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    cache_persistence_ttl</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">True</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><hr><h2 id="⚡-キャッシュのロード方法" tabindex="-1">⚡ キャッシュのロード方法 <a class="header-anchor" href="#⚡-キャッシュのロード方法" aria-label="Permalink to &quot;⚡ キャッシュのロード方法&quot;">​</a></h2><ol><li><strong>bulk_load=True (初期化時)</strong>: <ul><li>起動時に全データをメモリに読み込みます。</li><li><strong>ユースケース</strong>: データ量が数万件程度で、起動直後から高速なランダムアクセスが必要な場合。</li></ul></li><li><strong>デフォルト (遅延ロード)</strong>: <ul><li>アクセスされたデータのみをメモリに保持します。</li></ul></li></ol><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p>キャッシュを強制的に最新状態にしたい場合は <code>db.refresh(key)</code> または最新値をDBから直接引く <code>db.get_fresh(key)</code> を使用してください。 メモリ内の全キャッシュをクリアしたい場合は <code>db.clear_cache()</code> を呼び出します。</p></div><hr><h2 id="🔍-インデックスによる検索の高速化" tabindex="-1">🔍 インデックスによる検索の高速化 <a class="header-anchor" href="#🔍-インデックスによる検索の高速化" aria-label="Permalink to &quot;🔍 インデックスによる検索の高速化&quot;">​</a></h2><p><code>query()</code> や <code>query_with_pagination()</code> を使用して、Key-Valueペア以外のデータ（JSON内の特定フィールドなど）を検索する場合、インデックスが不可欠です。</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 検索対象となるJSONフィールドにインデックスを貼る</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">db.create_index(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;idx_user_age&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;data&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;age&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span></code></pre></div><p><strong>インデックス作成の目安</strong>:</p><ul><li>数千件を超えるデータに対して <code>WHERE</code> 句での検索を頻繁に行う場合。</li><li>データの挿入速度よりも検索速度を優先したい場合。</li></ul><hr><h2 id="💻-os・環境固有の注意点" tabindex="-1">💻 OS・環境固有の注意点 <a class="header-anchor" href="#💻-os・環境固有の注意点" aria-label="Permalink to &quot;💻 OS・環境固有の注意点&quot;">​</a></h2><h3 id="windows環境" tabindex="-1">Windows環境 <a class="header-anchor" href="#windows環境" aria-label="Permalink to &quot;Windows環境&quot;">​</a></h3><ul><li><strong>アンチウイルスソフト</strong>: SQLiteファイルの書き込み時にウイルススキャンが走ると、<code>database is locked</code> が発生しやすくなります。DBファイル（.db, .db-wal, .db-shm）をスキャン除外対象に設定することを推奨します。</li></ul><h3 id="ssd-vs-hdd" tabindex="-1">SSD vs HDD <a class="header-anchor" href="#ssd-vs-hdd" aria-label="Permalink to &quot;SSD vs HDD&quot;">​</a></h3><ul><li>SQLite はトランザクション毎に fsync を多用するため、ディスクの永続化レイテンシに強く依存します。HDD 環境ではこの同期コストが支配的となり、synchronous=OFF など耐障害性を犠牲にした設定が必要になる場合があります。可能であれば fsync 性能の高い SSD 上での運用を推奨します。</li></ul><hr><h2 id="チェックリスト" tabindex="-1">チェックリスト <a class="header-anchor" href="#チェックリスト" aria-label="Permalink to &quot;チェックリスト&quot;">​</a></h2><ul><li>[ ] 大量処理に <code>batch_update</code> を使っているか？</li><li>[ ] 頻繁な検索に <code>create_index</code> を適用しているか？</li><li>[ ] <code>optimize=True</code>（デフォルト）を使用しているか？</li><li>[ ] SSD環境で動作させているか？</li></ul>',58)])])}const g=i(n,[["render",h]]);export{c as __pageData,g as default};
