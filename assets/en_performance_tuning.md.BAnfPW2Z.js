import{_ as i,c as e,o as s,ae as t}from"./chunks/framework.C1dBqGw7.js";const k=JSON.parse('{"title":"Performance Tuning Guide","description":"","frontmatter":{},"headers":[],"relativePath":"en/performance_tuning.md","filePath":"en/performance_tuning.md"}'),n={name:"en/performance_tuning.md"};function o(l,a,h,r,d,p){return s(),e("div",null,[...a[0]||(a[0]=[t('<h1 id="performance-tuning-guide" tabindex="-1">Performance Tuning Guide <a class="header-anchor" href="#performance-tuning-guide" aria-label="Permalink to &quot;Performance Tuning Guide&quot;">‚Äã</a></h1><p>NanaSQLite is designed to be fast out of the box, but you can significantly boost its performance by choosing the right development patterns and configurations.</p><hr><h2 id="üöÄ-the-core-optimization-batch-operations" tabindex="-1">üöÄ The Core Optimization: Batch Operations <a class="header-anchor" href="#üöÄ-the-core-optimization-batch-operations" aria-label="Permalink to &quot;üöÄ The Core Optimization: Batch Operations&quot;">‚Äã</a></h2><p>The most expensive operation in SQLite is beginning and committing a transaction.</p><h3 id="‚ùå-anti-pattern-individual-writes-in-a-loop" tabindex="-1">‚ùå Anti-Pattern: Individual Writes in a Loop <a class="header-anchor" href="#‚ùå-anti-pattern-individual-writes-in-a-loop" aria-label="Permalink to &quot;‚ùå Anti-Pattern: Individual Writes in a Loop&quot;">‚Äã</a></h3><p>The following code is very slow because every iteration triggers a disk I/O operation.</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Triggers 1000 disk commits (can take seconds or even tens of seconds)</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> range</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">):</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    db[</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">f</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;key_</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">{</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">}</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i</span></span></code></pre></div><h3 id="‚úÖ-recommended-pattern-batch-update-batch-get" tabindex="-1">‚úÖ Recommended Pattern: <code>batch_update</code> / <code>batch_get</code> <a class="header-anchor" href="#‚úÖ-recommended-pattern-batch-update-batch-get" aria-label="Permalink to &quot;‚úÖ Recommended Pattern: `batch_update` / `batch_get`&quot;">‚Äã</a></h3><p>Using NanaSQLite&#39;s batch methods allows many operations to be processed in a single transaction, making it dramatically faster.</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Completes in a single disk commit (finished in milliseconds)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">f</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;key_</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">{</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">}</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> range</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)}</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">db.batch_update(data)</span></span></code></pre></div><p><strong>Benchmark Indicator</strong>: You can expect speedups of <strong>10x to 100x or more</strong> compared to individual updates for bulk operations.</p><hr><h2 id="‚ö°-database-configuration-optimizations" tabindex="-1">‚ö° Database Configuration Optimizations <a class="header-anchor" href="#‚ö°-database-configuration-optimizations" aria-label="Permalink to &quot;‚ö° Database Configuration Optimizations&quot;">‚Äã</a></h2><h3 id="wal-write-ahead-logging-mode" tabindex="-1">WAL (Write-Ahead Logging) Mode <a class="header-anchor" href="#wal-write-ahead-logging-mode" aria-label="Permalink to &quot;WAL (Write-Ahead Logging) Mode&quot;">‚Äã</a></h3><p>By default, NanaSQLite enables <strong>WAL mode</strong> when <code>optimize=True</code>.</p><ul><li><strong>Pros</strong>: Readers do not block writers, and writers do not block readers, greatly improving concurrency.</li><li><strong>Caveat</strong>: WAL mode may be unstable on network drives (NFS/SMB).</li></ul><h3 id="memory-mapped-i-o-mmap" tabindex="-1">Memory-Mapped I/O (mmap) <a class="header-anchor" href="#memory-mapped-i-o-mmap" aria-label="Permalink to &quot;Memory-Mapped I/O (mmap)&quot;">‚Äã</a></h3><p>NanaSQLite utilizes SQLite&#39;s <code>mmap_size</code> to improve read performance. It is set to 256MB by default.</p><hr><h2 id="üß†-caching-strategy-v1-3-0" tabindex="-1">üß† Caching Strategy (v1.3.0+) <a class="header-anchor" href="#üß†-caching-strategy-v1-3-0" aria-label="Permalink to &quot;üß† Caching Strategy (v1.3.0+)&quot;">‚Äã</a></h2><p>NanaSQLite provides multiple caching strategies to optimize the balance between memory usage and performance.</p><h3 id="_1-unbounded-cache-cachetype-unbounded" tabindex="-1">1. Unbounded Cache (<code>CacheType.UNBOUNDED</code>) <a class="header-anchor" href="#_1-unbounded-cache-cachetype-unbounded" aria-label="Permalink to &quot;1. Unbounded Cache (`CacheType.UNBOUNDED`)&quot;">‚Äã</a></h3><p>The <strong>default behavior</strong>. Once accessed, data is cached in memory indefinitely.</p><ul><li><strong>Pros</strong>: Fastest re-access for the same key.</li><li><strong>Caveat</strong>: Can lead to Out-Of-Memory (OOM) errors if the dataset is extremely large.</li></ul><h3 id="_2-lru-cache-cachetype-lru" tabindex="-1">2. LRU Cache (<code>CacheType.LRU</code>) <a class="header-anchor" href="#_2-lru-cache-cachetype-lru" aria-label="Permalink to &quot;2. LRU Cache (`CacheType.LRU`)&quot;">‚Äã</a></h3><p><strong>Introduced in v1.3.0</strong>. Set a limit on the number of items in the cache; the least recently used items are automatically evicted.</p><ul><li><strong>Usage</strong>: Specify <code>cache_strategy=CacheType.LRU, cache_size=1000</code>.</li><li><strong>Pros</strong>: Keeps memory usage predictable and capped.</li></ul><h3 id="‚ö°-speedup-options-orjson-lru-dict" tabindex="-1">‚ö° Speedup Options: <code>orjson</code> + <code>lru-dict</code> <a class="header-anchor" href="#‚ö°-speedup-options-orjson-lru-dict" aria-label="Permalink to &quot;‚ö° Speedup Options: `orjson` + `lru-dict`&quot;">‚Äã</a></h3><p>You can leverage <strong>orjson</strong> to significantly accelerate JSON serialization and deserialization.</p><ul><li><strong>orjson</strong>: Typically <strong>3x to 5x faster</strong> than the standard <code>json</code> module.</li><li><strong>lru-dict</strong>: A high-performance LRU data structure implemented as a C-extension.</li></ul><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Recommendation: Use quotes to prevent shell interpretation of brackets</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pip</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;nanasqlite[speed]&quot;</span></span></code></pre></div><p>NanaSQLite automatically detects and uses these if available. Otherwise, it falls back to standard library equivalents (<code>json</code>, <code>OrderedDict</code>).</p><h3 id="_3-ttl-cache-cachetype-ttl" tabindex="-1">3. TTL Cache (<code>CacheType.TTL</code>) <a class="header-anchor" href="#_3-ttl-cache-cachetype-ttl" aria-label="Permalink to &quot;3. TTL Cache (`CacheType.TTL`)&quot;">‚Äã</a></h3><p><strong>Introduced in v1.3.1</strong>. Set an expiration time for data to automatically invalidate old entries.</p><ul><li><strong>Usage</strong>: Set <code>cache_strategy=CacheType.TTL, cache_ttl=3600</code> (1 hour).</li><li><strong>Persistence TTL</strong>: Enable <code>cache_persistence_ttl=True</code> to automatically delete expired items from the SQLite database as well. Ideal for session management.</li></ul><h3 id="üìå-per-table-configuration" tabindex="-1">üìå Per-Table Configuration <a class="header-anchor" href="#üìå-per-table-configuration" aria-label="Permalink to &quot;üìå Per-Table Configuration&quot;">‚Äã</a></h3><p>Useful when you want to restrict memory usage only for specific tables (e.g., massive log tables).</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Main DB is unbounded, but logs table caches only the latest 100 entries.</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">logs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> db.table(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;logs&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">cache_strategy</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CacheType.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">LRU</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">cache_size</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Session table using 30-minute (1800s) TTL with automatic deletion from DB.</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sessions </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> db.table(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;sessions&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    cache_strategy</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CacheType.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TTL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    cache_ttl</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1800</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span></span>\n<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    cache_persistence_ttl</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">True</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><hr><h2 id="‚ö°-cache-loading-methods" tabindex="-1">‚ö° Cache Loading Methods <a class="header-anchor" href="#‚ö°-cache-loading-methods" aria-label="Permalink to &quot;‚ö° Cache Loading Methods&quot;">‚Äã</a></h2><ol><li><strong>bulk_load=True (at initialization)</strong>: <ul><li>Loads all data into memory at startup.</li><li><strong>Use Case</strong>: When you have tens of thousands of items and need high-speed random access immediately.</li></ul></li><li><strong>Default (Lazy Loading)</strong>: <ul><li>Only stores accessed data in memory.</li></ul></li></ol><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p>If you need to force a cache refresh, use <code>db.refresh(key)</code> or <code>db.get_fresh(key)</code> to fetch directly from the DB. To clear all in-memory cache, call <code>db.clear_cache()</code>.</p></div><hr><h2 id="üîç-fast-search-via-indexing" tabindex="-1">üîç Fast Search via Indexing <a class="header-anchor" href="#üîç-fast-search-via-indexing" aria-label="Permalink to &quot;üîç Fast Search via Indexing&quot;">‚Äã</a></h2><p>When using <code>query()</code> or <code>query_with_pagination()</code> to search for data other than the primary key (e.g., searching within JSON fields), indexing is essential.</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Create an index on a JSON field being searched</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">db.create_index(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;idx_user_age&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;data&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;age&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span></code></pre></div><p><strong>Indexing Guidelines</strong>:</p><ul><li>When frequently performing <code>WHERE</code> clause searches on datasets larger than a few thousand items.</li><li>When search speed is prioritized over insertion speed.</li></ul><hr><h2 id="üíª-os-and-environment-notes" tabindex="-1">üíª OS and Environment Notes <a class="header-anchor" href="#üíª-os-and-environment-notes" aria-label="Permalink to &quot;üíª OS and Environment Notes&quot;">‚Äã</a></h2><h3 id="windows" tabindex="-1">Windows <a class="header-anchor" href="#windows" aria-label="Permalink to &quot;Windows&quot;">‚Äã</a></h3><ul><li><strong>Antivirus Software</strong>: Real-time virus scanning during SQLite writes can lead to <code>database is locked</code> errors. We recommend excluding the database files (.db, .db-wal, .db-shm) from active scans.</li></ul><h3 id="ssd-vs-hdd" tabindex="-1">SSD vs HDD <a class="header-anchor" href="#ssd-vs-hdd" aria-label="Permalink to &quot;SSD vs HDD&quot;">‚Äã</a></h3><ul><li>SQLite relies heavily on fsync for every transaction, making it highly dependent on disk persistence latency. In HDD environments, this synchronization cost dominates performance, sometimes requiring settings that sacrifice fault tolerance, such as <code>synchronous=OFF</code>. We strongly recommend operating on SSDs with high fsync performance.</li></ul><hr><h2 id="checklist" tabindex="-1">Checklist <a class="header-anchor" href="#checklist" aria-label="Permalink to &quot;Checklist&quot;">‚Äã</a></h2><ul><li>[ ] Are you using <code>batch_update</code> for bulk processing?</li><li>[ ] Have you applied <code>create_index</code> for frequent searches?</li><li>[ ] Are you using the default <code>optimize=True</code>?</li><li>[ ] Is the database running on an SSD?</li></ul>',58)])])}const g=i(n,[["render",o]]);export{k as __pageData,g as default};
