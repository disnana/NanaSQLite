# NanaSQLite v1.3.0 キャッシュ機密設計書 (FIFO & TTL)

## 1. 目的
本ドキュメントは、NanaSQLite v1.3.0 におけるキャッシュ機能拡張の具体的な内部設計を規定します。
特に「高速パス（UNBOUNDED）の維持」と「TTL（有効期限）による自動管理」の両立に焦点を当てます。

## 2. モジュール構成

### 2.1. `src/nanasqlite/utils.py` [NEW]
汎用的な補助クラスを提供します。

#### `ExpiringDict(collections.abc.MutableMapping)` [Multi-Mode]
- **機能**: 規模と用途に応じて「期限切れ検知モード」を選択可能な高速辞書型。
- **サポートされるモード**:
    1. **`LAZY` (パッシブ)**: アクセス時のみ期限切れをチェック。バックグラウンド処理ゼロ。超軽量。大量のデータに最適。
    2. **`SCHEDULER` (推奨)**: 単一の共有ワーカーが監視。リソース消費を抑えつつ、順次メモリを解放。セッション管理に最適。
    3. **`TIMER` (高精度)**: 項目ごとに `threading.Timer` または `asyncio.sleep` を作成。極少数のキーで即時性が重要な場合に利用。
- **デフォルト動作**: `SCHEDULER` モード。
- **計算量**: GET/SET ともに $O(1)$。バックグラウンド負荷はモードにより $O(1)$〜$O(N)$。
- **コールバック**: `on_expire(key, value)` をサポート。

### 2.2. `src/nanasqlite/cache.py` [MODIFY]

#### `UnboundedCache` (FIFO 制限の追加)
- **設計**: `__init__(max_size: Optional[int] = None)`
- **ロジック**:
    - `set(key, value)` 時、`max_size` が指定されており、かつ現在のサイズが上限に達している場合、**最も古い要素**を削除する。
    - Python 3.7+ の `dict` は挿入順序を維持するため、`next(iter(self._data))` で取得できる最初のキーが最も古い要素（FIFO）となる。
    - GET 操作時は順序の変更を行わないため、オーバーヘッドは O(1) のまま維持される。

#### `TTLCache(CacheStrategy)` [NEW]
- **設計**: `ExpiringDict` を内部保持し、`CacheStrategy` プロトコルに適合させる。
- **パラメータ**: `max_size` (FIFO用), `ttl` (有効期限秒数), `on_expire` (オプションのコールバック)。
- **備考**:
    - `is_cached` や `mark_cached` のセマンティクスを NanaSQLite の遅延ロードロジックと整合させる。
    - 永続化 TTL モードの場合、`on_expire` 経由で `NanaSQLite` の削除メソッドを呼び出す。

#### `create_cache` 関数
- `CacheType.TTL` の追加。
- ストラテジーに応じた引数の振分けロジックの更新。

### 2.3. `src/nanasqlite/core.py` [MODIFY]
- `__init__`:
    - `cache_strategy`, `cache_size` に加え、`cache_ttl` 引数を追加受容。
    - **Persistence TTL**: `cache_persistence_ttl=True` オプションを追加。これが True の場合、キャッシュの有効期限切れ時に DB からもデータを削除する。
- `_setup_persistence_ttl()`:
    - `cache_persistence_ttl` が有効な場合、`TTLCache` に DB 削除ロジック (`self.pop(key, None)` など) をコールバックとして渡す。
- `clear_cache()`: 明示的なキャッシュ破棄の実装。

### 2.4. `src/nanasqlite/async_core.py` [MODIFY]
- `aclear_cache()`: スレッドプール経由で `self._db.clear_cache()` を呼び出す。
- `clear_cache()`: `aclear_cache` へのエイリアス。

---

## 3. 具体的なコード構造案

### UnboundedCache の FIFO ロジック
```python
def set(self, key: str, value: Any) -> None:
    if self._max_size and len(self._data) >= self._max_size:
        if key not in self._data: # 新規追加時のみ古いものを消す
            oldest_key = next(iter(self._data))
            del self._data[oldest_key]
            self._cached_keys.discard(oldest_key)
    
    self._data[key] = value
    self._cached_keys.add(key)
```

### TTLCache と Persistence TTL の統合イメージ
```python
# TTLCache 側
class TTLCache(CacheStrategy):
    def __init__(self, ttl: float, max_size: int | None = None, on_expire=None):
        self._data = ExpiringDict(expiration_time=ttl)
        if on_expire:
            self._data.set_on_expire_callback(on_expire)
        # ...

# NanaSQLite 側
if cache_strategy == CacheType.TTL and cache_persistence_ttl:
    def expire_callback(key, value):
        # ロックを取得して DB から削除（再帰に注意）
        with self._lock:
            self._delete_from_db(key)
    
    self._cache = TTLCache(ttl=cache_ttl, on_expire=expire_callback)
```

## 4. 検証項目
- **FIFO**: 上限 + 1 回の書き込み後、最初の 1 件が `in` で False になること。
- **TTL (Memory)**: `time.sleep(ttl + 0.1)` 後にデータが消えていること、および DB から再ロードされること。
- **Persistence TTL (Memory + DB)**: 有効期限切れ後、DB からもデータが消えており、再ロードしても取得できないこと。
- **Performance**: `UNBOUNDED` モードで `max_size=None` の場合、1.2.x 以前と性能差がないこと。
